#!/usr/bin/env bash

# Tiny curl-based OpenAI client using auth from ~/.codex/auth.json
# Requirements: bash, curl, python3

set -euo pipefail

AUTH_FILE="${HOME}/.codex/auth.json"

usage() {
  cat <<'USAGE'
Usage: tiny-openai-curl [options] "prompt text"

Options:
  -m, --model <name>     Model name (default: gpt-4o-mini)
  -s, --system <text>    System prompt (default: You are a helpful assistant.)
  -r, --raw              Print raw JSON response instead of extracted text
  -h, --help             Show this help

Reads OpenAI auth/config from ~/.codex/auth.json.
Recognized fields (any of):
  - api key:           openai.api_key | api_key | openai_api_key | token
  - organization:      openai.organization | organization | org | org_id
  - api base (root):   openai.api_base | api_base | base (e.g. https://api.openai.com)
USAGE
}

MODEL="gpt-4o-mini"
SYSTEM="You are a helpful assistant."
RAW=0

# Parse CLI args
ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -m|--model)
      MODEL="$2"; shift 2 ;;
    -s|--system)
      SYSTEM="$2"; shift 2 ;;
    -r|--raw)
      RAW=1; shift ;;
    -h|--help)
      usage; exit 0 ;;
    --)
      shift; break ;;
    -*)
      echo "Unknown option: $1" >&2; usage; exit 2 ;;
    *)
      ARGS+=("$1"); shift ;;
  esac
done

PROMPT=${ARGS[*]:-}

if [[ -z "${PROMPT}" ]] && [[ -t 0 ]]; then
  echo "Error: no prompt provided. Pass as argument or pipe via STDIN." >&2
  usage
  exit 1
fi

if [[ -z "${PROMPT}" ]]; then
  PROMPT="$(cat)"
fi

if [[ ! -f "$AUTH_FILE" ]]; then
  echo "Auth file not found: $AUTH_FILE" >&2
  exit 1
fi

# Extract auth/config robustly with Python (avoid jq dependency)
read -r API_KEY ORG API_BASE <<<"$(python3 - <<'PY'
import json, os
p = os.path.expanduser("~/.codex/auth.json")
data = {}
try:
    with open(p, 'r', encoding='utf-8') as f:
        data = json.load(f)
except Exception:
    pass

def pick(*paths):
    for path in paths:
        d = data
        try:
            for k in path.split('.'):
                d = d[k]
            if d:
                return str(d)
        except Exception:
            continue
    return ""

api_key = pick("openai.api_key", "api_key", "openai_api_key", "token")
org = pick("openai.organization", "organization", "org", "org_id")
base = pick("openai.api_base", "api_base", "base")

print((api_key or ""), (org or ""), (base or ""))
PY
)"

if [[ -z "${API_KEY}" ]]; then
  echo "API key not found in $AUTH_FILE" >&2
  exit 1
fi

# Default base and normalize to include /v1 suffix
if [[ -z "${API_BASE}" ]]; then
  API_BASE="https://api.openai.com"
fi
if [[ "${API_BASE}" != */v1 ]]; then
  API_BASE="${API_BASE%/}/v1"
fi

ENDPOINT="${API_BASE%/}/chat/completions"

# Build request body using Python for correct JSON escaping (no bash-specific quoting)
REQ_BODY=$(MODEL="$MODEL" SYSTEM="$SYSTEM" PROMPT="$PROMPT" python3 - <<'PY'
import json, os
body = {
    "model": os.environ.get("MODEL", "gpt-4o-mini"),
    "messages": [
        {"role": "system", "content": os.environ.get("SYSTEM", "You are a helpful assistant.")},
        {"role": "user", "content": os.environ.get("PROMPT", "")},
    ]
}
print(json.dumps(body))
PY
)

HDRS=(
  -H "Authorization: Bearer ${API_KEY}"
  -H "Content-Type: application/json"
)
if [[ -n "${ORG}" ]]; then
  HDRS+=( -H "OpenAI-Organization: ${ORG}" )
fi

HTTP_CODE=0
RESPONSE=$(
  curl -sS -w "\n%{http_code}" -X POST "$ENDPOINT" "${HDRS[@]}" \
    --data "$REQ_BODY" || true
)

# Separate body and HTTP code
HTTP_CODE="${RESPONSE##*$'\n'}"
BODY="${RESPONSE%$'\n'*}"

if [[ "$RAW" -eq 1 ]]; then
  printf "%s\n" "$BODY"
  exit 0
fi

# Try to extract the assistant message content; fall back to raw on failure
PARSED=$(python3 - <<'PY'
import json, os, sys
data = sys.stdin.read()
try:
    j = json.loads(data)
    # If error object present, print concise message
    if isinstance(j, dict) and 'error' in j:
        err = j['error']
        msg = getattr(err, 'get', lambda k, d=None: None)('message', None)
        if msg:
            print(f"[OpenAI error] {msg}")
            sys.exit(2)
    # Chat Completions format
    content = j.get('choices', [{}])[0].get('message', {}).get('content')
    if content:
        print(content)
        sys.exit(0)
except Exception:
    pass
print(data)
PY
<<< "$BODY")

printf "%s\n" "$PARSED"

# Return non-zero on non-2xx to surface HTTP errors in pipelines
case "$HTTP_CODE" in
  2*) exit 0 ;;
  *) exit 3 ;;
esac
